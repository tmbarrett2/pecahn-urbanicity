% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_urbanicity_iterative.R
\name{compute_urbanicity_iterative}
\alias{compute_urbanicity_iterative}
\title{Compute urbanicity metrics for multiple communities}
\usage{
compute_urbanicity_iterative(
  communities_list,
  metrics = c("all"),
  search_buffer = 1,
  friction_surface_path = NULL,
  population_raster_path = NULL,
  nighttime_light_path = NULL,
  verbose = FALSE
)
}
\arguments{
\item{communities_list}{A named list of community data (each containing \code{bbox}, \code{project}, \code{ethnicity}, and \code{community}).}

\item{metrics}{Character vector specifying which indicators to compute (\code{"all"} or subset).}

\item{search_buffer}{Degrees to expand friction surface cropping area (default = 1).}

\item{friction_surface_path}{Path to local friction surface raster.}

\item{population_raster_path}{Path to local population density raster.}

\item{nighttime_light_path}{Path to local nighttime light raster.}

\item{verbose}{Logical; if \code{TRUE}, prints intermediate output from each community run (default = \code{FALSE}).}
}
\value{
A combined \code{data.frame} with one row per community and columns for each calculated metric.
}
\description{
Iteratively applies \code{\link[=compute_urbanicity]{compute_urbanicity()}} across a list of communities, generating a combined data frame
of urbanicity indicators for each location. Displays a progress bar during execution.
}
\examples{
\dontrun{
results <- compute_urbanicity_iterative(
  communities_list = bbox_5km,
  metrics = "all",
  friction_surface_path = "friction_surface_walking.geotiff",
  population_raster_path = "pop_raster.tif",
  nighttime_light_path = "nighttime_lights.tif"
)
}

}
